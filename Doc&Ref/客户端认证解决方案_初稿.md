提供一个客户端与服务端进行认证的思路。

用于认证的信息：房卡、房间内客户端的UUID、时间戳。

每个客户端都有一个独特的UUID（酒店装修时每个终端生成的，并手工向服务端注册合法的UUID进行记录）。

验证的核心是token。通过管理员写入的信息、客户端的UUID、时间戳等信息通过SHA256等哈希方法生成token字串。客户端的初始化请求以及每一次控制请求，发送的数据包报文格式中，都应包含该token字串。

token验证包括用户房卡的认证信息、房间客户端的UUID、时间戳，这样可以确保“你在入住时间内在你的房间刷你的卡控制你的空调”。同时，还可以实现差异化pricing策略，比如根据用户订购的不同套餐，服务器在计费时提供优惠等计价策略。

整个流程应该就是check in时候前台（管理员）向房卡（或者手机）写入房间信息和时间戳等其他参数生成的token1，同时服务器记录这个token1，用于认证客户。如果想做手机控制，可以在check in的时候nfc刷一下（或者最土的用手机号登录），把手机的IMEI或者手机应用登录的账号跟房卡绑定，并且把这个信息也发给服务器生成token，服务器保存token并传给手机，之后手机控制就依赖这个唯一的token进行认证。

进入房间刷卡启动客户端的时候，客户端发送“初始化包”，发送自己的UUID和token1向服务器请求连接，服务器验证token1，并通过UUID和时间戳生成token2，保存本地并发送给客户端。在之后的session（客户入住时间）里，客户端每次控制空调请求，都在包中加入token1+token2的字段与服务器进行验证。（注意所有的token都应由服务器生成并控制）

当客户拔卡离开房间，客户端通知服务端暂停该房间的token验证。

当客户check out，前台管理员端计费结账，并且通知服务端销毁token1、token2，并且服务端通知客户端销毁所有token；或者当前时间超过预定退房时间，服务器自动地销毁存储的该房间token信息、并且通知客户端销毁token。客户端置为“未入住”的初始状态，等待下次登录。

所以登记入住之后，客户端的认证操作仅需要刷卡这一个动作完成，发送两个token，不需要账号密码；而管理员端控制逻辑和客户端不一样，因为使用者不具有流动性，管理员应提供账号密码进行登录认证，同样通过哈希算法生成token，并且与服务端保存的token进行比较，服务端不保存明文密码。（这也是所有的账号忘记密码都只能重设密码不能找回密码，并且服务器还提示你新密码不能和旧密码相同的原因，服务器也不知道你真正的密码是啥……）所以客户端和管理员端的初始化逻辑有所不同，但是之后的控制包报文格式应该都是一样的。我感觉报文应该需要数bit区分角色、需要有用于验证的token字段、还需要具体对服务器请求的控制码字段。