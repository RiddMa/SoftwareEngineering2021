# 软件工程概述

* 软件是包括程序、数据及其相关文档的完整集合。
* 软件开发至今未完全摆脱手工艺的开发方式。
* 软件危机：60-70s之间的软件快速发展阶段。
* 软件工程：运用工程化原则和方法，组织软件开发解决软件危机。
* 软件发展阶段：
    * <img src="C:\Users\Ridd\AppData\Roaming\Typora\typora-user-images\image-20210426140209741.png" alt="image-20210426140209741" style="zoom:50%;" />
* 软件工程定义：
    * 为了<u>经济地</u>获得能够在实际机器上高效运行的<u>可靠软件</u>而建立和使用的一系列好的<u>工程化原则</u>。
    * 运用现代科学技术知识来设计并构造计算机程序，及为开发、运行、维护这些程序必需的<u>相关文件资料</u>。
    * 在<u>成本限额以内按时</u>完成开发和修改软件产品所需的系统生产和维护的技术和管理的学科。
    * IEEE定义：1、应用<u>系统化的、规范化的、定量的方法</u>来开发、运行、维护软件，即<u>将工程应用到软件</u>。2、对1中各种方法的研究。
* 软件工程三要素：方法、工具和过程
    * 方法：提供了“如何做”的技术
    * 工具：提供自动或半自动的软件支撑环境
    * 过程：将软件工程的方法和工具综合起来达到合理、及时地进行计算机软件开发的目的
* 软件工程的目标：在给定成本和时间的前提下，开发出满足用户需求且具有正确性、可用性等因素的软件产品。
* 软件工程的终极目标：摆脱手工生产软件的状况，逐步实现软件研制和维护的自动化。

# 软件生命周期模型

* 工程项目三个基本目标：合理的进度、有限的经费、一定的质量
* <u>软件工程过程</u>是为了获得软件产品，在软件工具的支持下由软件工程师完成的一系列软件工程活动。主要活动：
    * 软件规格说明：规定软件功能及其使用限制
    * 软件开发：产生满足规格说明的软件
    * 软件确认：通过有效性验证以保证软件能够满足客户要求
    * 软件演进：为了满足客户变更要求，软件在使用过程中不断地改进
* 软件生命周期：制定计划、需求分析、设计、程序编码、测试、运行维护
* 传统模型种类：瀑布模型、演化模型、增量模型、喷泉模型、V&W模型、螺旋模型、构件组装模型、快速应用开发模型、原型方法。

## 瀑布模型

![image-20210427021908497](软件工程概述.assets/image-20210427021908497.png)

* 优点：降低软件开发复杂度、提高过程透明性和可管理性。推迟了软件实现，强调在软件实现前必须进行分析和设计工作。以项目阶段评审和文档控制为手段对整个开发过程进行指导。
* 缺点：模型缺乏灵活性，无法解决软件需求不明确或不准确的问题。模型的风险控制能力较弱。文档驱动极大地增加了工作量，仅凭文档评审容易得到错误结论。

## 演化模型

![image-20210427022136668](软件工程概述.assets/image-20210427022136668.png)

* 优点：明确用户需求、提高系统质量、降低开发风险。
* 缺点：难于管理、结构较差、技术不成熟。可能抛弃瀑布模型的文档控制优点。可能导致最终的软件系统结构较差。

## 增量模型

![image-20210427022313331](软件工程概述.assets/image-20210427022313331.png)

* 优点：先开发核心内容、风险较低、可靠性较强。
* 缺点：增量粒度难以选择、在开始确定所有需求比较困难。

## 喷泉模型（迭代模型）

![image-20210427022443756](软件工程概述.assets/image-20210427022443756.png)

* 优点：提高开发效率。缩短开发周期。
* 缺点：难于管理。

## V&W模型

![image-20210427022619844](软件工程概述.assets/image-20210427022619844.png)

瀑布模型将测试作为软件实现之后的一个独立阶段，使得在分析和设计阶段潜伏下来的错误得到纠正的时机大为推迟，造成较大的返工成本；而且体系结构级别的缺陷也只能在测试阶段才能被发现，使得瀑布模型驾驭风险的能力较低。

瀑布模型将测试阶段独立于编码之后，给人们造成了一种不良的影响，即：相对于编码而言，分析与设计工作更重要，而并没有强调测试的重要性，尽管测试有时会占据项目周期的一半时间。V模型的价值在于纠正了人们这种错误的认识，将测试分等级，并和前面的开发阶段对应起来。

## 螺旋模型

![image-20210427022801595](软件工程概述.assets/image-20210427022801595.png)

风险分析、制定计划、实施工程、客户评估四个阶段。适用于大型项目，逐渐明确需求、有效降低风险。

## 构件组装模型

![image-20210427023028972](软件工程概述.assets/image-20210427023028972.png)

* 优点：充分利用软件复用，提高开发效率。允许多个项目同时开发，降低费用、提高可维护性，实现分步提交软件产品。
* 缺点：缺乏通用的构件组装结构标准风险较大。构件可重用性和系统高效性之间不易协调。过于依赖构件使得构件质量影响最终产品质量。

## 快速应用开发模型

![image-20210427023228745](软件工程概述.assets/image-20210427023228745.png)

* 优点：极短的开发周期。
* 缺点：沟通配合不当容易导致开发失败。不适合开发技术风险性较高、与外围系统互操作性较高的系统。

## 原型方法

![image-20210427023438947](软件工程概述.assets/image-20210427023438947.png)

*
优点：原型方法有助于快速理解用户对于需求的真实想法。可以容易地确定系统的性能，确认各项主要系统服务的可应用性，确认系统设计的可行性，确认系统作为产品的结果。软件原型的最终版本，有的可以原封不动地成为产品，有的略加修改就可以成为最终系统的一个组成部分，这样有利于建成最终系统。
*
缺点：大型系统如不经过系统分析得到系统的整体划分，而直接用原型来模拟是很困难的。对于大量运算的、逻辑性较强的程序模块，原型方法很难构造出该模块的原型来供人评价。对于原有应用的业务流程、信息流程混乱的情况，原型构造与使用有一定的困难。文档容易被忽略。建立原型的许多工作会被浪费掉
。项目难以规划和管理。

## RUP，Rational Unified Process

* 将软件生命周期分为四个阶段：初始阶段、细化阶段、构造阶段、交付阶段。

![image-20210427024017373](软件工程概述.assets/image-20210427024017373.png)

![image-20210427024130748](软件工程概述.assets/image-20210427024130748.png)

![image-20210427024117773](软件工程概述.assets/image-20210427024117773.png)

# 软件需求分析

